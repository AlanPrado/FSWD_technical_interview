# Question 1

For a word n be an anagram of m word, all the letters in n should be contained
in m.

For example,
    m: "aaab"
    n: "aab"

Note that the amount of letters "a" from n should have less or equal the amount
of letter "a" from m.

To solve this problem we can count the frequency of each letter from the words
and verify if satisfy the both criteria explained above.


* Step 1: Counting letter frequency

For improve the letter search performance, we can make use of a dictionary.

m: { a: 3, b: 1 } and n: { a: 2, b: 1 }

* Step 2: Comparison

n['a'] <= m['a'] and n['b'] <= m['b']

Thus, n is an anagram of m.

## Time Complexity

____________| Worst _________| Average ________| Better _________
Step 1      | n + n          | n + n / 2       | n + 1
Step 2      | 1              | 13              | 26
O           | O(n)           | O(n)            | O(n)


Step 2: Comparison - Assuming that we have 26 letters at most, but the
important aspect is that we have a constant amount letter depending on charset.

## Space Complexity

____________| Worst _________| Average ________| Better _________
Step 1      | 2 * (26 + 26)  | 2 * (13 + 13)   | 2 * (1 + 1)
O           | O(1)           | O(1)            | O(1)

# Question 2

# Question 4

To find the least common ancestor between two nodes, just navigate in each node
until you found the root. For each path verify the first common node between
the nodes.

* Step 1: Find the parent

To find the parent, we navigate through all available nodes until we find the
node's parent.

For example,

When T = [[1, 0, 1],
          [0, 0, 0],
          [0, 0, 0]]

and  n1 = 0

We have to verify if each index in column 0 has the value 1.
If it has, the row (node) should be returned, otherwise check the next row
until all rows be checked.

This is a very costly operation because you must go through all rows and
columns in the worst case. To improve the performance, we could change T matrix
for a tree or a linked list.

* Step 2: Find the ancestors

For a given node find its parent until the parent be the root node.

To improve the performance of this step we allow the user to choose if the list
returned should be indexed or not and allow the user to create a stop condition.

If the path is indexed, does not maintain the order and is helpful for lookup,
otherwise it will maintain the finding order.

The stop condition can be used to avoid traversing until the root if a farthest
node is found first.

* Step 3: Find the farthest node

Find the ancestors of the node n1 without order. Then, perform the ancestor
search of the node n2 with order and a stop condition. Finally, pop the last
ancestor of n2.

## Time Complexity

______________| Worst _______________ | Average ___________________________________ | Better _________
Step 1, Step2 | (n * (n + 1)) / 2 + 1 | (floor(n / 2) * (floor(n / 2) + 1)) / 2 + 1 | 2
Step 3        | n + 2                 | floor(n / 2) * 2 + 1                        | 3
O             | O(n^2)                | O(n^2)                                      | O(1)

## Space Complexity

________________| Worst ___________ | Average _____________ | Better _________
availableNodes  | n                 | n                     | n
ancestorN1      | n - 1             | floor(n / 2)          | 1
ancestorN2      | 1                 | floor(n / 2)          | 1
O               | O(n)              | O(n)                  | O(n)

# Question 5

To find mth element from the end of the linked list, we need to navigate
through all the nodes until find last node keeping track of last m nodes.
Finally, pop the left element if the queue has at list m elements.

* Step 1: Traverse all nodes

To accomplish this task we just need to append the node in an double-ended queue
(deque) and navigate to the next node exists while it exists.

## Complexity

Worst case: m = n
Average case: m = log(n)
Average case: m = 1

## Time Complexity

_______| Worst ____________ | Average ____________ | Better ____________
Step 1 | n * n + 1          | n * (log(n) * 2) + 1 | 1 + 1
O      | O(n^2)             | O(n * log(n))        | O(1)

Step 1: As long as "append", "popleft" and "pop" are performed in constant time
(https://wiki.python.org/moin/TimeComplexity), this step would happen in
constant time, except for the fact that all nodes should be traversed.

## Space Complexity

_______| Worst ____________ | Average ____________ | Better ____________
Step 1 | n                  | log(n)               | 1
O      | O(n)               | O(log(n))            | O(1)

It's important to set the maxlen property of the deque to m in order to save
space.
